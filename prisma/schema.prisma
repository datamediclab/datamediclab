// Prisma schema â€” cleaned relation field names to avoid duplicate field errors
// Run: npx prisma migrate dev --name init_core
// After generating migration.sql, prepend: CREATE EXTENSION IF NOT EXISTS citext;

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Customer {
  id        Int            @id @default(autoincrement())
  fullName  String         @db.VarChar(150)
  phone     String         @unique @db.VarChar(30)
  email     String?        @unique @db.Citext
  lineId    String?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  notes     CustomerNote[]
  devices   Device[]

  @@index([phone])
  @@index([createdAt])
  @@index([updatedAt])
}

model Device {
  id               Int        @id @default(autoincrement())
  deviceType       DeviceType
  capacity         String
  serialNumber     String?    @unique @db.VarChar(120)
  description      String?
  currentStatus    StatusEnum @default(WAITING_FOR_CUSTOMER_DEVICE)
  statusHistoryRaw Json?
  technicianNote   String?
  receivedAt       DateTime   @default(now())
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  customerId       Int
  brandId          Int
  modelId          Int?

  brand    Brand       @relation(fields: [brandId], references: [id], onDelete: Restrict)
  customer Customer    @relation(fields: [customerId], references: [id], onDelete: Restrict)
  model    BrandModel? @relation(fields: [modelId], references: [id], onDelete: Restrict)

  paymentRecords  PaymentRecord[]
  statusHistories StatusHistory[]
  trackLogs       TrackLog[]
  repairRecords   RepairRecord[]
  recoveryJobs    RecoveryJob[]

  @@index([customerId, receivedAt])
  @@index([currentStatus])
  @@index([brandId])
  @@index([modelId])
  @@index([updatedAt])
}

model PaymentRecord {
  id       Int           @id @default(autoincrement())
  amount   Decimal       @db.Decimal(12, 2)
  method   PaymentMethod
  paidAt   DateTime      @default(now())
  note     String?
  deviceId Int
  device   Device        @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@index([deviceId, paidAt])
}

model Admin {
  id            Int             @id @default(autoincrement())
  name          String
  email         String          @unique @db.Citext
  password      String
  role          UserRole
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  statusChanged StatusHistory[] @relation("StatusChangedBy")
  technicianFor RepairRecord[]  @relation("RepairRecordTechnician")
  actorLogs     TrackLog[]      @relation("TrackLogActor")
  assignedJobs  RecoveryJob[]   @relation("AssignedRecoveryJobs")

  @@index([updatedAt])
}

model Brand {
  id        Int          @id @default(autoincrement())
  name      String       @unique @db.VarChar(120)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  models    BrandModel[]
  devices   Device[]

  @@index([updatedAt])
}

model BrandModel {
  id        Int      @id @default(autoincrement())
  name      String   @db.VarChar(120)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  brandId   Int
  brand     Brand    @relation(fields: [brandId], references: [id], onDelete: Restrict)
  devices   Device[]

  @@unique([name, brandId])
  @@index([updatedAt])
}

model CustomerNote {
  id         Int      @id @default(autoincrement())
  note       String
  createdAt  DateTime @default(now())
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model RecoveryJob {
  id              Int        @id @default(autoincrement())
  deviceId        Int
  assignedAdminId Int?
  status          StatusEnum
  note            String?
  createdAt       DateTime   @default(now())
  device          Device     @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  assignedAdmin   Admin?     @relation("AssignedRecoveryJobs", fields: [assignedAdminId], references: [id])
}

model RepairRecord {
  id                Int      @id @default(autoincrement())
  repairDate        DateTime @default(now())
  description       String?
  cost              Decimal  @db.Decimal(12, 2)
  note              String?
  createdAt         DateTime @default(now())
  deviceId          Int
  technicianAdminId Int?
  device            Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  technician        Admin?   @relation("RepairRecordTechnician", fields: [technicianAdminId], references: [id])
}

model StatusHistory {
  id               Int        @id @default(autoincrement())
  from             StatusEnum
  to               StatusEnum
  note             String?
  changedAt        DateTime   @default(now())
  deviceId         Int
  changedByAdminId Int?
  changedBy        Admin?     @relation("StatusChangedBy", fields: [changedByAdminId], references: [id])
  device           Device     @relation(fields: [deviceId], references: [id], onDelete: Cascade)
}

model TrackLog {
  id           Int      @id @default(autoincrement())
  action       String
  note         String?
  createdAt    DateTime @default(now())
  deviceId     Int
  actorAdminId Int?
  actor        Admin?   @relation("TrackLogActor", fields: [actorAdminId], references: [id])
  device       Device   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
}

enum StatusEnum {
  WAITING_FOR_CUSTOMER_DEVICE
  UNDER_DIAGNOSIS
  ANALYSIS_COMPLETE
  RECOVERY_IN_PROGRESS
  RECOVERY_SUCCESSFUL
  RECOVERY_FAILED
  DEVICE_RETURNED
}

enum PaymentMethod {
  CASH
  TRANSFER
  CREDIT_CARD
  PROMPT_PAY
}

enum UserRole {
  ADMIN
  STAFF
  SUPERADMIN
}

enum DeviceType {
  HDD
  SSD
  EXTERNAL_DRIVE
  FLASH_DRIVE
  MEMORY_CARD
  OTHER
}
